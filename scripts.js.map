{"version":3,"sources":["src/assets/app.js","src/assets/encoder-wav-worker.js","src/assets/RecorderService.js","src/assets/WebAudioPeakMeter.js"],"names":[],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,4EAA4E;AAC5E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;CC3FA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,qBAAqB;AACtC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;CC5EA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,+BAA+B,SAAS,0BAA0B;AAClE;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,6BAA6B;AACtE;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wCAAwC,yBAAyB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0DAA0D,UAAU,uBAAuB,EAAE;AAC7F;;AAEA;AACA;AACA;AACA;AACA;AACA;;CCnOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA,0BAA0B,6BAA6B;AACvD,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"scripts.js","sourcesContent":["\"use strict\";\r\n\r\nclass App {\r\n  constructor () {\r\n    this.btnRecord = document.getElementById('btn-record');\r\n    this.btnStop = document.getElementById('btn-stop');\r\n\r\n    this.debugTxt = document.getElementById('debug-txt')\r\n\r\n    this.recordingsCont = document.getElementById('recordings-cont')\r\n\r\n    this.isRecording = false\r\n    this.saveNextRecording = false\r\n\r\n    this.debugTxt.innerHTML = \"stopped\"\r\n  }\r\n\r\n  init () {\r\n    this._initEventListeners()\r\n  }\r\n\r\n  _initEventListeners () {\r\n\r\n    this.btnRecord.addEventListener('click', evt => {\r\n      this._stopAllRecording()\r\n      this.saveNextRecording = true\r\n      this._startRecording()\r\n\r\n      this.btnRecord.disabled = true\r\n      this.btnStop.disabled = false\r\n      this.debugTxt.innerHTML = \"recording\"\r\n    })\r\n\r\n    this.btnStop.addEventListener('click', evt => {\r\n      this._stopAllRecording();\r\n\r\n      this.btnRecord.disabled = false\r\n      this.btnStop.disabled = true\r\n      this.debugTxt.innerHTML = \"stopped\"\r\n    })\r\n  }\r\n\r\n  _startRecording () {\r\n    if (!this.recorderSrvc) {\r\n      this.recorderSrvc = new RecorderService()\r\n      this.recorderSrvc.em.addEventListener('recording', (evt) => this._onNewRecording(evt))\r\n    }\r\n\r\n    if (!this.webAudioPeakMeter) {\r\n      this.webAudioPeakMeter = new WebAudioPeakMeter()\r\n      this.meterEl = document.getElementById('recording-meter')\r\n    }\r\n\r\n    this.recorderSrvc.onGraphSetupWithInputStream = (inputStreamNode) => {\r\n      this.meterNodeRaw = this.webAudioPeakMeter.createMeterNode(inputStreamNode, this.recorderSrvc.audioCtx)\r\n      this.webAudioPeakMeter.createMeter(this.meterEl, this.meterNodeRaw, {})\r\n    }\r\n\r\n    this.recorderSrvc.startRecording()\r\n    this.isRecording = true\r\n    this.debugTxt.innerHTML = \"recording...\"\r\n  }\r\n\r\n  _stopAllRecording () {\r\n    if (this.recorderSrvc && this.isRecording) {\r\n\r\n      this.recorderSrvc.stopRecording()\r\n      this.isRecording = false\r\n\r\n      if (this.meterNodeRaw) {\r\n        this.meterNodeRaw.disconnect()\r\n        this.meterNodeRaw = null\r\n        this.meterEl.innerHTML = ''\r\n      }\r\n    }\r\n  }\r\n\r\n  _onNewRecording (evt) {\r\n    if (!this.saveNextRecording) {\r\n      return\r\n    }\r\n    const newIdx = this.recordingsCont.childNodes.length + 1\r\n\r\n    const newEl = document.createElement('div')\r\n    newEl.innerHTML = '<audio id=\"audio-recording-' + newIdx + '\" controls></audio>'\r\n    this.recordingsCont.appendChild(newEl)\r\n\r\n    const recordingEl = document.getElementById(\"audio-recording-\" + newIdx);\r\n    recordingEl.src = evt.detail.recording.blobUrl\r\n    recordingEl.type = evt.detail.recording.mimeType\r\n  }\r\n}\r\n","// Parts copied from https://github.com/chris-rudmin/Recorderjs\r\nlet BYTES_PER_SAMPLE = 2\r\nlet recorded = []\r\n\r\nfunction encode (buffer) {\r\n  let length = buffer.length\r\n  let data = new Uint8Array(length * BYTES_PER_SAMPLE)\r\n  for (let i = 0; i < length; i++) {\r\n    let index = i * BYTES_PER_SAMPLE\r\n    let sample = buffer[i]\r\n    if (sample > 1) {\r\n      sample = 1\r\n    }\r\n    else if (sample < -1) {\r\n      sample = -1\r\n    }\r\n    sample = sample * 32768\r\n    data[index] = sample\r\n    data[index + 1] = sample >> 8\r\n  }\r\n  recorded.push(data)\r\n}\r\n\r\nfunction dump (sampleRate) {\r\n  let bufferLength = recorded.length ? recorded[0].length : 0\r\n  let length = recorded.length * bufferLength\r\n  let wav = new Uint8Array(44 + length)\r\n\r\n  let view = new DataView(wav.buffer)\r\n\r\n  // RIFF identifier 'RIFF'\r\n  view.setUint32(0, 1380533830, false)\r\n  // file length minus RIFF identifier length and file description length\r\n  view.setUint32(4, 36 + length, true)\r\n  // RIFF type 'WAVE'\r\n  view.setUint32(8, 1463899717, false)\r\n  // format chunk identifier 'fmt '\r\n  view.setUint32(12, 1718449184, false)\r\n  // format chunk length\r\n  view.setUint32(16, 16, true)\r\n  // sample format (raw)\r\n  view.setUint16(20, 1, true)\r\n  // channel count\r\n  view.setUint16(22, 1, true)\r\n  // sample rate\r\n  view.setUint32(24, sampleRate, true)\r\n  // byte rate (sample rate * block align)\r\n  view.setUint32(28, sampleRate * BYTES_PER_SAMPLE, true)\r\n  // block align (channel count * bytes per sample)\r\n  view.setUint16(32, BYTES_PER_SAMPLE, true)\r\n  // bits per sample\r\n  view.setUint16(34, 8 * BYTES_PER_SAMPLE, true)\r\n  // data chunk identifier 'data'\r\n  view.setUint32(36, 1684108385, false)\r\n  // data chunk length\r\n  view.setUint32(40, length, true)\r\n\r\n  for (var i = 0; i < recorded.length; i++) {\r\n    wav.set(recorded[i], i * bufferLength + 44)\r\n  }\r\n\r\n  recorded = []\r\n  let msg = [wav.buffer]\r\n  postMessage(msg, [msg[0]])\r\n}\r\n\r\nonmessage = function (e) {\r\n  if (e.data[0] === 'encode') {\r\n    encode(e.data[1])\r\n  }\r\n  else if (e.data[0] === 'dump') {\r\n    dump(e.data[1])\r\n  }\r\n  else if (e.data[0] === 'close') {\r\n    self.close()\r\n  }\r\n}\r\n\r\n","class RecorderService {\r\n    constructor () {\r\n      window.AudioContext = window.AudioContext || window.webkitAudioContext\r\n  \r\n      this.em = document.createDocumentFragment()\r\n  \r\n      this.state = 'inactive'\r\n  \r\n      this.chunks = []\r\n      this.chunkType = ''\r\n  \r\n      this.encoderMimeType = 'audio/wav'\r\n  \r\n      this.config = {\r\n        manualEncoderId: 'wav',\r\n        micGain: 1.0,\r\n        processorBufferSize: 2048,\r\n        stopTracksAndCloseCtxWhenFinished: true,\r\n        usingMediaRecorder: typeof window.MediaRecorder !== 'undefined',\r\n        //userMediaConstraints: { audio: true }\r\n        userMediaConstraints: { audio: { echoCancellation: false } }\r\n      }\r\n    }\r\n  \r\n    /* Returns promise */\r\n    startRecording () {\r\n      if (this.state !== 'inactive') {\r\n        return\r\n      }\r\n  \r\n      // This is the case on ios/chrome, when clicking links from within ios/slack (sometimes), etc.\r\n      if (!navigator || !navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\r\n        alert('Missing support for navigator.mediaDevices.getUserMedia') // temp: helps when testing for strange issues on ios/safari\r\n        return\r\n      }\r\n  \r\n      this.audioCtx = new AudioContext()\r\n      this.micGainNode = this.audioCtx.createGain()\r\n      this.outputGainNode = this.audioCtx.createGain()\r\n  \r\n      // If not using MediaRecorder(i.e. safari and edge), then a script processor is required. It's optional\r\n      // on browsers using MediaRecorder and is only useful if wanting to do custom analysis or manipulation of\r\n      // recorded audio data.\r\n      if (!this.config.usingMediaRecorder) {\r\n        this.processorNode = this.audioCtx.createScriptProcessor(this.config.processorBufferSize, 1, 1) // TODO: Get the number of channels from mic\r\n      }\r\n  \r\n      // Create stream destination on chrome/firefox because, AFAICT, we have no other way of feeding audio graph output\r\n      // in to MediaRecorder. Safari/Edge don't have this method as of 2018-04.\r\n      if (this.audioCtx.createMediaStreamDestination) {\r\n        this.destinationNode = this.audioCtx.createMediaStreamDestination()\r\n      }\r\n      else {\r\n        this.destinationNode = this.audioCtx.destination\r\n      }\r\n  \r\n      // Create web worker for doing the encoding\r\n      if (!this.config.usingMediaRecorder) {\r\n        this.encoderWorker = new Worker('js/encoder-wav-worker.js')\r\n        this.encoderMimeType = 'audio/wav'\r\n  \r\n        this.encoderWorker.addEventListener('message', (e) => {\r\n          let event = new Event('dataavailable')\r\n          event.data = new Blob(e.data, { type: this.encoderMimeType })\r\n          this._onDataAvailable(event)\r\n        })\r\n      }\r\n  \r\n      // This will prompt user for permission if needed\r\n      return navigator.mediaDevices.getUserMedia(this.config.userMediaConstraints)\r\n        .then((stream) => {\r\n          this._startRecordingWithStream(stream)\r\n        })\r\n        .catch((error) => {\r\n          alert('Error with getUserMedia: ' + error.message) // temp: helps when testing for strange issues on ios/safari\r\n          console.log(error)\r\n        })\r\n    }\r\n  \r\n    _startRecordingWithStream (stream) {\r\n      this.micAudioStream = stream\r\n  \r\n      this.inputStreamNode = this.audioCtx.createMediaStreamSource(this.micAudioStream)\r\n      this.audioCtx = this.inputStreamNode.context\r\n  \r\n      // Allow optionally hooking in to audioGraph inputStreamNode, useful for meters\r\n      if (this.onGraphSetupWithInputStream) {\r\n        this.onGraphSetupWithInputStream(this.inputStreamNode)\r\n      }\r\n  \r\n      this.inputStreamNode.connect(this.micGainNode)\r\n      this.micGainNode.gain.setValueAtTime(this.config.micGain, this.audioCtx.currentTime)\r\n  \r\n      let nextNode = this.micGainNode\r\n  \r\n      this.state = 'recording'\r\n  \r\n      if (this.processorNode) {\r\n        nextNode.connect(this.processorNode)\r\n        this.processorNode.connect(this.outputGainNode)\r\n        this.processorNode.onaudioprocess = (e) => this._onAudioProcess(e)\r\n      }\r\n      else {\r\n        nextNode.connect(this.outputGainNode)\r\n      }\r\n  \r\n      this.outputGainNode.connect(this.destinationNode)\r\n  \r\n      if (this.config.usingMediaRecorder) {\r\n        this.mediaRecorder = new MediaRecorder(this.destinationNode.stream)\r\n        this.mediaRecorder.addEventListener('dataavailable', (evt) => this._onDataAvailable(evt))\r\n        this.mediaRecorder.addEventListener('error', (evt) => this._onError(evt))\r\n  \r\n        this.mediaRecorder.start()\r\n      }\r\n      else {\r\n        // Output gain to zero to prevent feedback. Seems to matter only on Edge, though seems like should matter\r\n        // on iOS too.  Matters on chrome when connecting graph to directly to audioCtx.destination, but we are\r\n        // not able to do that when using MediaRecorder.\r\n        this.outputGainNode.gain.setValueAtTime(0, this.audioCtx.currentTime)\r\n      }\r\n    }\r\n  \r\n    _onAudioProcess (e) {\r\n      if (this.config.broadcastAudioProcessEvents) {\r\n        this.em.dispatchEvent(new CustomEvent('onaudioprocess', {\r\n          detail: {\r\n            inputBuffer: e.inputBuffer,\r\n            outputBuffer: e.outputBuffer\r\n          }\r\n        }))\r\n      }\r\n  \r\n      // Safari and Edge require manual encoding via web worker. Single channel only for now.\r\n      // Example stereo encoderWav: https://github.com/MicrosoftEdge/Demos/blob/master/microphone/scripts/recorderworker.js\r\n      if (!this.config.usingMediaRecorder) {\r\n        if (this.state === 'recording') {\r\n          if (this.config.broadcastAudioProcessEvents) {\r\n            this.encoderWorker.postMessage(['encode', e.outputBuffer.getChannelData(0)])\r\n          }\r\n          else {\r\n            this.encoderWorker.postMessage(['encode', e.inputBuffer.getChannelData(0)])\r\n          }\r\n        }\r\n      }\r\n    }\r\n  \r\n    stopRecording () {\r\n      if (this.state === 'inactive') {\r\n        return\r\n      }\r\n  \r\n      if (this.config.usingMediaRecorder) {\r\n        this.state = 'inactive'\r\n        this.mediaRecorder.stop()\r\n      }\r\n      else {\r\n        this.state = 'inactive'\r\n        this.encoderWorker.postMessage(['dump', this.audioCtx.sampleRate])\r\n      }\r\n    }\r\n  \r\n    _onDataAvailable (evt) {\r\n      this.chunks.push(evt.data)\r\n      this.chunkType = evt.data.type\r\n  \r\n      if (this.state !== 'inactive') {\r\n        return\r\n      }\r\n  \r\n      let blob = new Blob(this.chunks, { 'type': this.chunkType })\r\n      let blobUrl = URL.createObjectURL(blob)\r\n      const recording = {\r\n        ts: new Date().getTime(),\r\n        blobUrl: blobUrl,\r\n        mimeType: blob.type,\r\n        size: blob.size\r\n      }\r\n  \r\n      this.chunks = []\r\n      this.chunkType = null\r\n  \r\n      if (this.destinationNode) {\r\n        this.destinationNode.disconnect()\r\n        this.destinationNode = null\r\n      }\r\n      if (this.outputGainNode) {\r\n        this.outputGainNode.disconnect()\r\n        this.outputGainNode = null\r\n      }\r\n  \r\n      if (this.processorNode) {\r\n        this.processorNode.disconnect()\r\n        this.processorNode = null\r\n      }\r\n  \r\n      if (this.encoderWorker) {\r\n        this.encoderWorker.postMessage(['close'])\r\n        this.encoderWorker = null\r\n      }\r\n  \r\n      if (this.micGainNode) {\r\n        this.micGainNode.disconnect()\r\n        this.micGainNode = null\r\n      }\r\n      if (this.inputStreamNode) {\r\n        this.inputStreamNode.disconnect()\r\n        this.inputStreamNode = null\r\n      }\r\n  \r\n      if (this.config.stopTracksAndCloseCtxWhenFinished) {\r\n        // This removes the red bar in iOS/Safari\r\n        this.micAudioStream.getTracks().forEach((track) => track.stop())\r\n        this.micAudioStream = null\r\n  \r\n        this.audioCtx.close()\r\n        this.audioCtx = null\r\n      }\r\n  \r\n      this.em.dispatchEvent(new CustomEvent('recording', { detail: { recording: recording } }))\r\n    }\r\n  \r\n    _onError (evt) {\r\n      console.log('error', evt)\r\n      this.em.dispatchEvent(new Event('error'))\r\n      alert('error:' + evt) // for debugging purposes\r\n    }\r\n  }\r\n  ","/**\r\n * Copied from https://github.com/esonderegger/web-audio-peak-meter\r\n * Modified to class form to allow multiple instances on a page.\r\n */\r\n class WebAudioPeakMeter {\r\n    constructor () {\r\n      this.options = {\r\n        borderSize: 2,\r\n        fontSize: 9,\r\n        backgroundColor: 'black',\r\n        tickColor: '#ddd',\r\n        gradient: ['red 1%', '#ff0 16%', 'lime 45%', '#080 100%'],\r\n        dbRange: 48,\r\n        dbTickSize: 6,\r\n        maskTransition: 'height 0.1s'\r\n      }\r\n  \r\n      // this.tickWidth\r\n      // this.elementWidth\r\n      // this.elementHeight\r\n      // this.meterHeight\r\n      // this.meterWidth\r\n      // this.meterTop\r\n      this.vertical = true\r\n      this.channelCount = 1\r\n      this.channelMasks = []\r\n      this.channelPeaks = []\r\n      this.channelPeakLabels = []\r\n    }\r\n  \r\n    getBaseLog (x, y) {\r\n      return Math.log(y) / Math.log(x)\r\n    }\r\n  \r\n    dbFromFloat (floatVal) {\r\n      return this.getBaseLog(10, floatVal) * 20\r\n    }\r\n  \r\n    setOptions (userOptions) {\r\n      for (var k in userOptions) {\r\n        this.options[k] = userOptions[k]\r\n      }\r\n      this.tickWidth = this.options.fontSize * 2.0\r\n      this.meterTop = this.options.fontSize * 1.5 + this.options.borderSize\r\n    }\r\n  \r\n    createMeterNode (sourceNode, audioCtx) {\r\n      var c = sourceNode.channelCount\r\n      var meterNode = audioCtx.createScriptProcessor(2048, c, c)\r\n      sourceNode.connect(meterNode)\r\n      meterNode.connect(audioCtx.destination)\r\n      return meterNode\r\n    }\r\n  \r\n    createContainerDiv (parent) {\r\n      var meterElement = document.createElement('div')\r\n      meterElement.style.position = 'relative'\r\n      meterElement.style.width = this.elementWidth + 'px'\r\n      meterElement.style.height = this.elementHeight + 'px'\r\n      meterElement.style.backgroundColor = this.options.backgroundColor\r\n      parent.appendChild(meterElement)\r\n      return meterElement\r\n    }\r\n  \r\n    createMeter (domElement, meterNode, optionsOverrides) {\r\n      this.setOptions(optionsOverrides)\r\n      this.elementWidth = domElement.clientWidth\r\n      this.elementHeight = domElement.clientHeight\r\n      var meterElement = this.createContainerDiv(domElement)\r\n      if (this.elementWidth > this.elementHeight) {\r\n        this.vertical = false\r\n      }\r\n      this.meterHeight = this.elementHeight - this.meterTop - this.options.borderSize\r\n      this.meterWidth = this.elementWidth - this.tickWidth - this.options.borderSize\r\n      this.createTicks(meterElement)\r\n      this.createRainbow(meterElement, this.meterWidth, this.meterHeight,\r\n        this.meterTop, this.tickWidth)\r\n      this.channelCount = meterNode.channelCount\r\n      var channelWidth = this.meterWidth / this.channelCount\r\n      var channelLeft = this.tickWidth\r\n      for (var i = 0; i < this.channelCount; i++) {\r\n        this.createChannelMask(meterElement, this.options.borderSize,\r\n          this.meterTop, channelLeft, false)\r\n        this.channelMasks[i] = this.createChannelMask(meterElement, channelWidth,\r\n          this.meterTop, channelLeft,\r\n          this.options.maskTransition)\r\n        this.channelPeaks[i] = 0.0\r\n        this.channelPeakLabels[i] = this.createPeakLabel(meterElement, channelWidth,\r\n          channelLeft)\r\n        channelLeft += channelWidth\r\n      }\r\n      meterNode.onaudioprocess = (e) => this.updateMeter(e)\r\n      meterElement.addEventListener('click', function () {\r\n        for (var i = 0; i < this.channelCount; i++) {\r\n          this.channelPeaks[i] = 0.0\r\n          this.channelPeakLabels[i].textContent = '-∞'\r\n        }\r\n      }, false)\r\n    }\r\n  \r\n    createTicks (parent) {\r\n      var numTicks = Math.floor(this.options.dbRange / this.options.dbTickSize)\r\n      var dbTickLabel = 0\r\n      var dbTickTop = this.options.fontSize + this.options.borderSize\r\n      for (var i = 0; i < numTicks; i++) {\r\n        var dbTick = document.createElement('div')\r\n        parent.appendChild(dbTick)\r\n        dbTick.style.width = this.tickWidth + 'px'\r\n        dbTick.style.textAlign = 'right'\r\n        dbTick.style.color = this.options.tickColor\r\n        dbTick.style.fontSize = this.options.fontSize + 'px'\r\n        dbTick.style.position = 'absolute'\r\n        dbTick.style.top = dbTickTop + 'px'\r\n        dbTick.textContent = dbTickLabel + ''\r\n        dbTickLabel -= this.options.dbTickSize\r\n        dbTickTop += this.meterHeight / numTicks\r\n      }\r\n    }\r\n  \r\n    createRainbow (parent, width, height, top, left) {\r\n      var rainbow = document.createElement('div')\r\n      parent.appendChild(rainbow)\r\n      rainbow.style.width = width + 'px'\r\n      rainbow.style.height = height + 'px'\r\n      rainbow.style.position = 'absolute'\r\n      rainbow.style.top = top + 'px'\r\n      rainbow.style.left = left + 'px'\r\n      var gradientStyle = 'linear-gradient(' + this.options.gradient.join(', ') + ')'\r\n      rainbow.style.backgroundImage = gradientStyle\r\n      return rainbow\r\n    }\r\n  \r\n    createPeakLabel (parent, width, left) {\r\n      var label = document.createElement('div')\r\n      parent.appendChild(label)\r\n      label.style.width = width + 'px'\r\n      label.style.textAlign = 'center'\r\n      label.style.color = this.options.tickColor\r\n      label.style.fontSize = this.options.fontSize + 'px'\r\n      label.style.position = 'absolute'\r\n      label.style.top = this.options.borderSize + 'px'\r\n      label.style.left = left + 'px'\r\n      label.textContent = '-∞'\r\n      return label\r\n    }\r\n  \r\n    createChannelMask (parent, width, top, left, transition) {\r\n      var channelMask = document.createElement('div')\r\n      parent.appendChild(channelMask)\r\n      channelMask.style.width = width + 'px'\r\n      channelMask.style.height = this.meterHeight + 'px'\r\n      channelMask.style.position = 'absolute'\r\n      channelMask.style.top = top + 'px'\r\n      channelMask.style.left = left + 'px'\r\n      channelMask.style.backgroundColor = this.options.backgroundColor\r\n      if (transition) {\r\n        channelMask.style.transition = this.options.maskTransition\r\n      }\r\n      return channelMask\r\n    }\r\n  \r\n    maskSize (floatVal) {\r\n      if (floatVal === 0.0) {\r\n        return this.meterHeight\r\n      }\r\n      else {\r\n        var d = this.options.dbRange * -1\r\n        var returnVal = Math.floor(this.dbFromFloat(floatVal) * this.meterHeight / d)\r\n        if (returnVal > this.meterHeight) {\r\n          return this.meterHeight\r\n        }\r\n        else {\r\n          return returnVal\r\n        }\r\n      }\r\n    }\r\n  \r\n    updateMeter (audioProcessingEvent) {\r\n      var inputBuffer = audioProcessingEvent.inputBuffer\r\n      var i\r\n      var channelData = []\r\n      var channelMaxes = []\r\n      for (i = 0; i < this.channelCount; i++) {\r\n        channelData[i] = inputBuffer.getChannelData(i)\r\n        channelMaxes[i] = 0.0\r\n      }\r\n      for (var sample = 0; sample < inputBuffer.length; sample++) {\r\n        for (i = 0; i < this.channelCount; i++) {\r\n          if (Math.abs(channelData[i][sample]) > channelMaxes[i]) {\r\n            channelMaxes[i] = Math.abs(channelData[i][sample])\r\n          }\r\n        }\r\n      }\r\n      for (i = 0; i < this.channelCount; i++) {\r\n        var thisMaskSize = this.maskSize(channelMaxes[i], this.meterHeight)\r\n        this.channelMasks[i].style.height = thisMaskSize + 'px'\r\n        if (channelMaxes[i] > this.channelPeaks[i]) {\r\n          this.channelPeaks[i] = channelMaxes[i]\r\n          var labelText = this.dbFromFloat(this.channelPeaks[i]).toFixed(1)\r\n          this.channelPeakLabels[i].textContent = labelText\r\n        }\r\n      }\r\n    }\r\n  }\r\n  "],"sourceRoot":"webpack:///"}